基于您选定的技术栈（Next.js、Tailwind CSS、PostgreSQL、Vercel），我为您的国际新闻管理系统设计了一套完整的全栈解决方案。这份设计文档将作为您的开发蓝图。

首先，我们通过下面这个架构图来直观了解系统的全貌和数据流动过程：

```
flowchart TD
    subgraph Frontend [前端展示层 - Next.js 14+]
        A1[App Router<br>与页面]
        A2[React 组件<br>与状态管理]
        A3[Tailwind CSS<br>样式]
    end

    subgraph Backend [后端逻辑层 - Next.js API Routes]
        B1[API Routes<br>业务逻辑]
        B2[NextAuth.js<br>身份认证]
        B3[Prisma Client<br>数据操作]
    end

    subgraph Data [数据层]
        C[(PostgreSQL<br>数据库)]
    end

    subgraph Deploy [部署平台]
        D[Vercel<br>托管平台]
    end

    A1 -->|HTTP 请求| B1
    B1 -->|Prisma 查询| C
    C -->|返回数据| B1
    B1 -->|JSON 响应| A1
    D -->|自动部署| Frontend
    D -->|环境变量 & 连接池| Backend
    D -.->|Vercel Postgres| C
```

------

### 数据库设计 (PostgreSQL with Prisma)

新闻系统的核心是数据模型，采用以下设计以支持多语言和灵活的内容管理。

#### 核心数据模型

在项目根目录下的 `prisma/schema.prisma`文件中定义数据模型：

```
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  role      UserRole @default(EDITOR)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  articles  Article[]
  accounts  Account[] // NextAuth
  sessions  Session[] // NextAuth
  @@map("users")
}

model Article {
  id          String   @id @default(cuid())
  slug        String   @unique // 用于生成友好的URL，如 "how-to-learn-nextjs"
  status      ArticleStatus @default(DRAFT)
  featured    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  publishedAt DateTime? // 定时发布
  authorId    String
  author      User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  // 多语言内容关联：一篇新闻的不同语言版本
  locales     ArticleLocale[]
  categories  Category[] // 多对多关系
  @@map("articles")
}

// 核心：支持多语言的内容表
model ArticleLocale {
  id         String   @id @default(cuid())
  language   String   // 语言代码，如 'en', 'zh-CN'
  title      String   // 标题
  content    String   // 正文内容（可存储为Markdown或富文本）
  excerpt    String?  // 摘要
  metaDescription String? // 用于SEO
  articleId  String
  article    Article  @relation(fields: [articleId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([articleId, language]) // 确保一篇新闻同种语言只有一个版本
  @@map("article_locales")
}

model Category {
  id          String   @id @default(cuid())
  slug        String   @unique
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  articles    Article[]
  locales     CategoryLocale[]
  @@map("categories")
}

// 分类的多语言名称
model CategoryLocale {
  id          String   @id @default(cuid())
  name        String
  language    String
  categoryId  String
  category    Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  @@unique([categoryId, language])
  @@map("category_locales")
}

// NextAuth.js 所需的模型（根据NextAuth官方文档）
model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String? @db.Text
  access_token       String? @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String? @db.Text
  session_state      String?
  user               User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime
  @@unique([identifier, token])
}

enum UserRole {
  ADMIN
  EDITOR
  CONTRIBUTOR
}

enum ArticleStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}
```

#### 数据库初始化

1. **推送模式到数据库**：运行 `npx prisma db push`将上述模式同步到您的 PostgreSQL 数据库。
2. **生成 Prisma Client**：运行 `npx prisma generate`，这会在您的 Node.js 模块中生成一个针对您的数据模型定制的高效数据库客户端，用于后续的数据库操作。

------

### API 设计 (Next.js API Routes)

所有 API 端点均位于 `/app/api/`目录下，遵循 RESTful 设计原则。

| 功能模块     | HTTP 方法   | 端点                      | 需要认证    | 描述                                                         |
| ------------ | ----------- | ------------------------- | ----------- | ------------------------------------------------------------ |
| **文章管理** | `GET`       | `/api/articles`           | 否          | 获取文章列表，支持分页、过滤（按状态、分类、语言）和搜索。   |
|              | `POST`      | `/api/articles`           | 是          | 创建新文章。                                                 |
|              | `GET`       | `/api/articles/[id]`      | 否          | 根据 ID 获取单篇文章的完整内容。                             |
|              | `PUT/PATCH` | `/api/articles/[id]`      | 是          | 更新文章。                                                   |
|              | `DELETE`    | `/api/articles/[id]`      | 是          | 删除文章。                                                   |
| **分类管理** | `GET`       | `/api/categories`         | 否          | 获取所有分类列表。                                           |
|              | `POST`      | `/api/categories`         | 是（Admin） | 创建新分类。                                                 |
| **文件上传** | `POST`      | `/api/upload`             | 是          | 图片等静态文件上传，返回访问URL。建议整合Vercel Blob或Cloudinary。 |
| **认证**     | `GET`       | `/api/auth/[...nextauth]` | -           | NextAuth.js 的认证端点，处理登录、注销等。                   |

#### 示例 API 实现

以下是创建文章和获取文章列表 API 的核心代码逻辑，展示了如何在 Next.js API Route 中处理请求、认证和数据库操作：

```
// app/api/articles/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import prisma from '@/lib/prisma'; // 全局的 PrClient 实例
import { authOptions } from '../auth/[...nextauth]/route';

// POST /api/articles - 创建新文章
export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions);
  // 认证检查
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const body = await request.json();
    const { slug, status, featured, locales, categoryIds } = body;

    const articleData = {
      slug,
      status,
      featured,
      authorId: session.user.id, // 从 session 中获取作者 ID
      locales: {
        create: locales, // 利用 Prisma 的嵌套创建，同时创建多语言内容
      },
      categories: {
        connect: categoryIds?.map((id: string) => ({ id })), // 连接已存在的分类
      },
    };

    const newArticle = await prisma.article.create({
      data: articleData,
      include: {
        locales: true,
        categories: true,
        author: { select: { name: true } },
      },
    });

    return NextResponse.json(newArticle, { status: 201 });
  } catch (error) {
    console.error('POST /api/articles error:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}

// GET /api/articles - 获取文章列表（支持分页、筛选、搜索）
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const language = searchParams.get('language') || 'en';
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '10');
    const categorySlug = searchParams.get('category');
    const status = searchParams.get('status') as ArticleStatus | null;
    const searchQuery = searchParams.get('search');

    const skip = (page - 1) * limit;

    // 构建查询条件
    const where: any = {};
    if (status) where.status = status;
    if (categorySlug) {
      where.categories = { some: { slug: categorySlug } };
    }
    if (searchQuery) {
      where.locales = {
        some: {
          OR: [
            { title: { contains: searchQuery, mode: 'insensitive' } },
            { content: { contains: searchQuery, mode: 'insensitive' } },
          ],
          language: language,
        },
      };
    }

    // 并行查询：获取文章列表和总数
    const [articles, totalCount] = await Promise.all([
      prisma.article.findMany({
        where,
        skip,
        take: limit,
        include: {
          locales: { where: { language } },
          categories: { include: { locales: { where: { language } } } },
          author: { select: { name: true } },
        },
        orderBy: { createdAt: 'desc' },
      }),
      prisma.article.count({ where }),
    ]);

    return NextResponse.json({
      articles,
      pagination: { page, limit, totalCount, totalPages: Math.ceil(totalCount / limit) },
    });
  } catch (error) {
    console.error('GET /api/articles error:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}
```

------

### 前端与 UI 设计 (Next.js & Tailwind CSS)

#### 核心页面结构（App Router）

- `app/[lang]/(public)/layout.tsx`：公共布局，包含多语言提供器、主导航。
- `app/[lang]/(public)/page.tsx`：首页，展示头条新闻和新闻列表。
- `app/[lang]/(public)/news/[slug]/page.tsx`：新闻详情页。
- `app/[lang]/(protected)/admin/layout.tsx`：管理后台布局。
- `app/[lang]/(protected)/admin/articles/page.tsx`：文章管理列表页。
- `app/[lang]/(protected)/admin/articles/new/page.tsx`：创建/编辑文章页。

#### 国际化实现

使用 `next-intl`等库是实现前端国际化的高效方式。它在 Next.js App Router 上提供了易于使用的抽象。

1. 

   **创建翻译文件**：在 `messages/`目录下为每种语言创建 JSON 文件，例如 `en.json`和 `zh-CN.json`。

   ```
   // messages/en.json
   {
     "Navigation": {
       "home": "Home",
       "news": "News",
       "about": "About Us"
     },
     "HomePage": {
       "headline": "International News",
       "latestNews": "Latest Updates"
     }
   }
   ```

2. **配置中间件**：用于根据浏览器语言或用户偏好自动重定向到正确的语言版本。

3. **在组件中使用**：在您的 React 组件中调用 `useTranslations`hook 来获取翻译文本。

#### 样式与主题

使用 Tailwind CSS 的实用类来构建响应式、美观的界面。您可以利用其 `prose`类（来自 `@tailwindcss/typography`插件）来优雅地呈现新闻正文的 HTML 内容。

------

### 部署配置 (Vercel)

1. **环境变量**：在 Vercel 项目的设置中，配置以下环境变量： `DATABASE_URL`：您的 PostgreSQL 数据库连接字符串。 `NEXTAUTH_URL`：您应用的完整 URL，例如 `https://yournews.vercel.app`。 `NEXTAUTH_SECRET`：一个随机的、高强度的字符串，用于加密会话。 （如果使用 OAuth）`GITHUB_CLIENT_ID`和 `GITHUB_CLIENT_SECRET`等。

2. 

   **构建命令**：Vercel 会自动检测 Next.js 项目。确保您的 `package.json`中的 `build`脚本包含 Prisma Client 的生成步骤：

   ```
   "scripts": {
     "build": "prisma generate && next build",
     "db-push": "prisma db push"
   }
   ```

3. **Vercel Postgres**：强烈考虑使用 Vercel Postgres，它可以与您的项目无缝集成，简化连接池和配置。

### 补充说明与最佳实践

- **性能优化**：对新闻列表页使用 **增量静态再生（ISR）**，对不常变的页面（如关于我们）使用 **静态站点生成（SSG）**，对高度动态的内容使用服务端渲染（SSR）。
- **图片优化**：始终使用 Next.js 的 `next/image`组件，它会自动优化图片并提供现代格式（如 WebP）。
- **类型安全**：在整个项目（前端组件和 API 路由）中充分利用 TypeScript，以增强代码的可靠性和开发体验。
- **内容安全策略**：考虑配置 CSP 头以防止 XSS 等攻击。

